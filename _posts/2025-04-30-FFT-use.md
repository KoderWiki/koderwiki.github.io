---
layout: post
title: ë¼ëˆë³€í™˜ê³¼ FFT ê·¸ë¦¬ê³  CT
tags: [Radon Transfrom, FFT, Iine Integral, Computer Algorithm]
feature-img: "assets/img/0.post/2025-05-02/0.png"
thumbnail: "assets/img/0.post/2025-05-02/0.png"
categories: ALGORITHM
---

## FFTì˜ ì‹¤ìƒí™œ ì ìš©

**í‘¸ë¦¬ì— ë³€í™˜**(Fourier transform, **FT**)ì€ ì‹œê°„ì´ë‚˜ ê³µê°„ì— ëŒ€í•œ í•¨ìˆ˜ë¥¼ ì‹œê°„ ë˜ëŠ” ê³µê°„ ì£¼íŒŒìˆ˜ ì„±ë¶„ìœ¼ë¡œ ë¶„í•´í•˜ëŠ” ë³€í™˜ì„ ë§í•œë‹¤.<br>
<br>
**í‘¸ë¦¬ì— ê¸‰ìˆ˜/ë³€í™˜**ì˜ ëª©ì ì€ ì–´ë–¤ í•¨ìˆ˜ f(t)ì— ëŒ€í•´ ì£¼ì–´ì§„ ì‹œê°„ ì¶•ì—ì„œ ë‹¤ìˆ˜ì˜ **ì‚¬ì¸íŒŒ** ë˜ëŠ” **ì½”ì‚¬ì¸íŒŒ**ë¡œ ë¶„í•´í•˜ëŠ” ê²ƒì´ë‹¤<br>
<br>
**FFT**ëŠ” ìš°ë¦¬ê°€ ì¸ì‹í•˜ì§€ ëª»í•  ë¿, **ìŒì•…**,**ì˜ìƒ**,**ì˜ë£Œ**ë“± ë§ì€ ì˜ì—­ì—ì„œ ì‚¬ìš©ë˜ê³  ìˆë‹¤.<br>
<br>
ì´ì¤‘ ì˜ë£Œ ì˜ìƒ ì¤‘ **ì»´í“¨í„° ë‹¨ì¸µì´¬ì˜ (CT)**ì— ë„ì…í•´ ë³¼ ê²ƒì´ë‹¤.

## ì»´í“¨í„° ë‹¨ì¸µì´¬ì˜ (CT)

**ì»´í“¨í„°ë‹¨ì¸µì´¬ì˜, CT(Computed Tomography)**ëŠ” Xì„  ë°œìƒì¥ì¹˜ê°€ ìˆëŠ” ì›í†µí˜•ì˜ ê¸°ê³„ë¥¼ ì‚¬ìš©í•´ ë‚´ë¶€ë¥¼ ì´¬ì˜í•˜ëŠ” ê¸°ìˆ , ë˜ëŠ” ê·¸ëŸ¬í•œ ê¸°ìˆ ì„ ì‚¬ìš©í•œ ì˜í•™ ê²€ì‚¬ì´ë‹¤. <br>
<br>
![image](https://github.com/user-attachments/assets/754fd546-811c-4de5-8b33-c2b96a859b25)
<br>
ìœ„ ì‚¬ì§„ê³¼ ê°™ì´ Xì„ ì„ ëª¸ì— íˆ¬ì˜ì‹œì¼œ **ì ë¶„ì„ í†µí•´ ê°ì‡ ë¡œ ì¸í•œ ê°’**ì„ ì €ì¥í•˜ì—¬ ì‚¬ì§„ìœ¼ë¡œ ë³µì›í•œë‹¤<br>
<br>
![image](https://github.com/user-attachments/assets/5867baec-9e57-4cd5-8da2-1fa8f4dcf650)
<br>
**ì¦‰, CTì´¬ì˜ ê²°ê³¼ì˜ ì›ë³¸ì€ ìš°ë¦¬ê°€ í”íˆ ì•„ëŠ” ì‚¬ì§„ì´ ì•„ë‹Œ Sinogramìœ¼ë¡œ ì´ë£¨ì–´ì ¸ ìˆë‹¤**<br>

![image](https://github.com/user-attachments/assets/134b6633-859b-4bb3-a2ef-0490ec54ca58)
<br> 
Sinogramì´ ì–´ë–»ê²Œ ì–»ëŠ”ì§€; ìš°ë¦¬ê°€ í”íˆ ì•„ëŠ” CTì‚¬ì§„ì´ ë˜ëŠ”ì§€ ì•Œì•„ë³´ì

## Radon Transform

ìˆ˜í•™ì—ì„œ **ë¼ëˆ ë³€í™˜**ì€ í‰ë©´ì—ì„œ ì •ì˜ëœ í•¨ìˆ˜ë¥¼ 2ì°¨ì› ê³µê°„ì—ì„œ ì •ì˜ëœ í•¨ìˆ˜ë¡œ ë³€í™˜í•˜ëŠ” **ì ë¶„ë³€í™˜**ì´ë‹¤<br>
íŠ¹ì • ì„ ì—ì„œì˜ ê°’ì€ í•´ë‹¹ ì„ ìœ„ì˜ í•¨ìˆ˜ì˜ **ì„ ì ë¶„**ê³¼ ê°™ë‹¤<br>
ì •ë¦¬í•˜ìë©´, ë¼ëˆë³€í™˜ì˜ í•µì‹¬ ì—°ì‚°ì€ **ì„ ì ë¶„**ì´ë©° CTì´¬ì˜ì—ì„œ ëª¸ì— Xì„ ì„ **ì—¬ëŸ¬ ê°ë„**ë¡œ íˆ¬ê³¼ì‹œí‚¤ë©´ì„œ **ì„ ì ë¶„**ì„ í•˜ê³ , ê·¸ Xì„  íˆ¬ê³¼ê²°ê³¼ê°€ **Sinogram**ì´ë‹¤.<br>
<br>
$$
R f(\theta, s) = \int_{-\infty}^{\infty} \int_{-\infty}^{\infty} f(x, y) \, \delta(x \cos\theta + y \sin\theta - s) \, dx \, dy
$$
<br>

## Inverse Radon Transform

ë¼ëˆë³€í™˜ìœ¼ë¡œ Sinogramì„ ì–»ëŠ”ë‹¤í•˜ë”ë¼ë„ ì§ê´€ì ìœ¼ë¡œ ì´ë¥¼ ë¶„ì„í•˜ê¸° ì–´ë µë‹¤. <br>
ë”°ë¼ì„œ Sinogramì„ ë‹¤ì‹œ **ì—­ë³€í™˜**ì„ í•´ì„œ ìš°ë¦¬ì˜ ëª¸ ë‹¨ì¸µì˜ ì´ë¯¸ì§€ë¥¼ ì–»ëŠ”ë‹¤. <br>
ë‹¨ìˆœíˆ Sinogramì„ ë‹¤ë°©ë©´ìœ¼ë¡œ **ì ë¶„**ì„ í•´ì„œ ì›ë³¸ì˜ ì´ë¯¸ì§€ë¥¼ ì–»ì„ê²ƒì´ë¼ ìƒê°í•  ìˆ˜ë„ ìˆì§€ë§Œ, **ê·¸ë ‡ì§€ ì•Šë‹¤**<br>
ì ë¶„ë§Œìœ¼ë¡œ ì—­ë³€í™˜ì„ í•  ê²½ìš°, **ì´ë¯¸ì§€ê°€ í¼ì ¸ì„œ íë¦¿í•´ë³´ì¼ ìˆ˜ ìˆê¸° ë•Œë¬¸ì—** ë‹¤ìŒê³¼ ê°™ì€ ê³¼ì •ì„ ê±°ì³ì•¼ í•œë‹¤.
<br>

> - **Frequency domain filtering(ì£¼íŒŒìˆ˜ ë„ë©”ì¸ í•„í„°ë§)**
> - **BackProjection(ë°±í”„ë¡œì ì…˜)**
<br>


#### Frequency Domain Filtering (ì£¼íŒŒìˆ˜ ë„ë©”ì¸ í•„í„°ë§)

ìœ„ì— ë§í–ˆë“¯ì´ ë¼ëˆë³€í™˜ì€ **ì €ì£¼íŒŒê°€ ê°•ì¡°ë˜ì„œ** ë‹¨ìˆœíˆ ì ë¶„ë§Œ í•˜ë©´ íë¦¿í•´ ì§€ê¸° ë•Œë¬¸ì— ë¨¼ì € **í•„í„°ë§** ê³¼ì •ì„ ê±°ì¹œë‹¤. <br>
í¬ê²Œ ë³´ë©´ **ì‹ í˜¸ë‚˜ ì´ë¯¸ì§€ë¥´ë¥´ ë” ì •í™•íˆ í•´ì„í•˜ê³  ì›í•˜ëŠ” ì •ë³´ë§Œ ì¶”ì¶œí•˜ê¸° ìœ„í•´ì„œ**ì´ë‹¤.<br>

**í•„í„°ë§ ê³¼ì •**
<br>
> - ê°ë„ ğœƒë§ˆë‹¤ $R_f(\theta, s)$ ì„ ì¶”ì¶œí•œë‹¤
> - sì— ëŒ€í•´ **í‘¸ë¦¬ì— ë³€í™˜**ì„ ì‚¬ìš©í•´ì„œ **ì£¼íŒŒìˆ˜** ë³€í™˜í•œë‹¤
> - **ì£¼íŒŒìˆ˜ë¡œ ë°”ê¾¸ë©´ ì›í•˜ëŠ” ë¶€ë¶„ë§Œ ì‰½ê²Œ ì¡°ì‘í•  ìˆ˜ ìˆë‹¤**
> - ì£¼íŒŒìˆ˜ì— **$H(\omega)$** ê³±í•œë‹¤ (ëŒ€í‘œì ìœ¼ë¡œ **Ram-lak filter**)
> - ë‹¤ì‹œ **í‘¸ë¦¬ì— ì—­ë³€í™˜**ì„ í•œë‹¤

<br>
**Fourier Transform ì‚¬ìš© ì´ìœ **
<br>

**ì‹œê°„ ì˜ì—­**ì—ì„œ í•„í„°ë§ì€ ë³µì¡í•˜ì§€ë§Œ **ì£¼íŒŒìˆ˜ ì˜ì—­**ì—ì„œëŠ” **ë‹¨ìˆœ ê³±ì…ˆ**ìœ¼ë¡œ ë‚˜ì˜¨ë‹¤<br>

$$
x(t) * h(t) \xrightarrow{\mathcal{F}} X(\omega) \cdot H(\omega)
$$

<br>
**Ram-Lak Filter**
<br>

ìœ„ì— ì£¼íŒŒìˆ˜ì— ê³±í•˜ëŠ” **í•„í„° í•¨ìˆ˜**ì—ì„œ ëŒ€í‘œì ìœ¼ë¡œ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ë‹¤.<br>
<br>
$$
H(\omega) = |\omega| \quad \text{(high-pass filter)}
$$
<br>

> - ì €ì£¼íŒŒ ì„±ë¶„ ì–µì œ (ë¼ëˆë³€í™˜ì€ ì €ì£¼íŒŒê°€ ê°•ì¡°ëœë‹¤)
> - ê³ ì£¼íŒŒ ê°•ì¡° (ê²½ê³„ë¥¼ ì‚´ë ¤ì„œ íë¦¼ì„ ë°©ì§€í•œë‹¤)
<br>

## Backprojection (ë°±í”„ë¡œì ì…˜)

**ë°±í”„ë¡œì ì…˜(Backprojection)**ì´ë€, ë¼ëˆ ë³€í™˜(ì„ ì ë¶„)ìœ¼ë¡œ ì–»ì€ Sinogram ë°ì´í„°ë¥¼ ì´ë¯¸ì§€ í‰ë©´ìœ¼ë¡œ ë˜ì˜ì•„ ì›ë˜ ì´ë¯¸ì§€ë¥¼ ë³µì›í•˜ëŠ” ê³¼ì •ì´ë‹¤. <br>
ë¼ëˆë³€í™˜ì€ **ì—¬ëŸ¬ ê°ë„ì—ì„œ xì„ ë°©í–¥ìœ¼ë¡œ ì„ ì ë¶„** í•œ ê²ƒì´ê¸° ë•Œë¬¸ì— ì„ ì ë¶„ ê°’ì„ **ê·¸ ì§ì„ ì„ ë”°ë¼ ë¿Œë¦¬ê³  ëª¨ë“  ê°ë„ë¡œ ë°˜ë³µí•´ì„œ ëˆ„ì **ì‹œí‚¤ë©´ ì›ë˜ì˜ ì´ë¯¸ì§€ê°€ ë³µì›ëœë‹¤. <br>

$$
f(x, y) \approx \int_0^\pi \text{FilteredProjection}(\theta, s)\, d\theta \quad \text{where } s = x \cos \theta + y \sin \theta
$$
<br>

> - (x,y) : ë³µì› í•  ì´ë¯¸ì§€ì˜ ì¢Œí‘œ
> - ğœƒ :  ê°ë„
> - s : ì ìœ„ í•´ë‹¹ë˜ëŠ” íˆ¬ì˜ ì§ì„  ìœ„ì¹˜
> - **ëª¨ë“  ê°ë„ë³„ë¡œ sinogramì—ì„œ í•´ë‹¹ ì¢Œí‘œê°’ì„ ë‹¤ ë”í•œë‹¤**
> - ìœ„ì—ì„œ ë§í–ˆë“¯ì´ ê·¸ëƒ¥ backprojectì„ í•  ê²½ìš° íë¦¿í•´ì§€ê¸° ë•Œë¬¸ì— í•„í„°ë§ì„ ê±°ì¹œë‹¤


**ì´ì œ ì´ë¥¼ ì½”ë“œë¡œ êµ¬í˜„í•´ ë³´ì**

## Implement in Code

**source code**<br>
Python ì†ŒìŠ¤ì½”ë“œ íŒŒì¼ì²¨ë¶€ | [CT Medical Image](https://wiki.cancerimagingarchive.net/display/Public/TCGA-LUAD) <br>
**run**<br>
32.53s

## Radon Transfrom

**ê³¼ì • ìš”ì•½**<br>

> - ë¼ëˆë³€í™˜ì€ ì´ë¯¸ì§€ë¥¼ **ì—¬ëŸ¬ê°ë„ë¡œ íšŒì „** ì‹œì¼œì•¼ í•˜ëŠ”ë° **íšŒì „ ê³¼ì •ì—ì„œ ì´ë¯¸ì§€ê°€ ì˜ë¦´ ìˆ˜ ë„ ìˆë‹¤**.
> - ë•Œë¬¸ì— ì˜ë¦¬ëŠ”ê²ƒì„ ë°©ì§€í•˜ê¸°ìœ„í•´ **ì˜ë¦¬ì§€ ì•ŠëŠ” ìµœì†Œí¬ê¸°(ëŒ€ê°ì„ )** ë§Œí¼ **íŒ¨ë”©**ì„ í•´ì¤€ë‹¤
> - ì›ë˜ëŠ” CTê°€ íšŒì „í•˜ë©´ì„œ íˆ¬ì˜í•˜ëŠ” ê²ƒì„ ì´ë¯¸ì§€ë¥¼ íšŒì „í•˜ë©´ì„œ íˆ¬ì˜í•˜ëŠ” ê²ƒìœ¼ë¡œ êµ¬í˜„í•œë‹¤.
> - íšŒì „ëœ ì´ë¯¸ì§€ì— ëŒ€í•´ **ì„ ì ë¶„**ì„ í•œë‹¤.
> - ê²°ê³¼ë¥¼ sinogramìœ¼ë¡œ ìŒ“ê³  ë°˜í™˜í•œë‹¤.
> - ì—¬ê¸°ì„œ ì„ ì ë¶„ì€ ì‹¤ì œë¡œ ì„ ì ë¶„ ì—°ì‚°ì„ í•˜ì§€ëŠ” ì•ŠëŠ”ë‹¤. **ì´ë¯¸ì§€ê°€ í”½ì…€ë¡œ ì¡°ë°€í•˜ê¸° ë•Œë¬¸ì— ìˆ˜ì¹˜ê·¼ì‚¬**í•œë‹¤
> - **ë””ì§€í„¸ ì´ë¯¸ì§€**ëŠ” ì—°ì†ì´ ì•„ë‹Œ **discrete**í•˜ê¸° ë•Œë¬¸ì— ì ë¶„ëŒ€ì‹  **í”½ì…€ ì¤„ í•©ì‚°**ì„ í•œë‹¤
> - ì‹¤ì œë¡œë„ CT ìŠ¤ìºë„ˆë„ **ë¬´í•œí•œ í•´ìƒë„ë¡œ ì„ ì ë¶„í•˜ëŠ” ê²ƒì´ ì•„ë‹Œ ì´ì‚°ë°ì´í„°**ë¥¼ ë°›ì•„ì„œ **ìˆ˜ì¹˜ê·¼ì‚¬**í•œë‹¤

```python
# ì´ë¯¸ì§€ëŠ” í‘ë°±ì´ë¯¸ì§€ë¥¼ ë‹´ëŠ”ë‹¤ (ë¼ëˆë³€í™˜ì€ ìƒ‰ë³´ë‹¤ ë°ê¸°ì •ë³´ì— ë¯¼ê°)
# ë˜í•œ í‘ë°±ì€ 2D (64x64)ì§€ë§Œ RGBëŠ” 3D (64x64x3) ë°°ì—´ì´ì—¬ì„œ ë©”ëª¨ë¦¬ ì ˆì•½ë„ ê°€ëŠ¥
def radon_transform(image, angles):

    # h : ë†’ì´ w : ë„ˆë¹„
    h, w = image.shape

    # ëŒ€ê°ì„  ê¸¸ì´ ê³„ì‚°
    diag_len = int(np.ceil(np.sqrt(h**2 + w**2)))

    # zero-pedding (ì´ë¯¸ì§€ íšŒì „ì‹œ ì†ìƒ ë°©ì§€)
    pad_width = ((diag_len - h) // 2, (diag_len - w) // 2)
    padded = np.pad(image, (pad_width, pad_width), mode='constant', constant_values=0)

    sinogram = []

    for theta in angles:
        # ì´ë¯¸ì§€ íšŒì „ (reshape = False : ì´ë¯¸ì§€ í¬ê¸°ìœ ì§€, order = 1: 1ì°¨ ì„ í˜•ë³´ê°„)
        # ì„ í˜•ë³´ê°„ : ë‘ì ì‚¬ì´ì˜ ì§ì„ ì˜ ë°©ì •ì‹ (order = 1 : 1ì°¨)
        rotated = rotate(padded, angle=theta, reshape=False, order=1)

        # ê°ë„ì—ì„œ ìˆ˜ì§ ë°©í–¥ìœ¼ë¡œ ì„ ì ë¶„ (í”½ì…€ í•©)
        projection = np.sum(rotated, axis=0)
        sinogram.append(projection)

    # ê²°ê³¼ê°’ ë°©í–¥ì´ 90ë„ ëŒì•„ê°€ìˆì–´ì„œ ì „ì¹˜í–‰ë ¬ë¡œ ë°”ê¿”ì¤Œ
    return np.array(sinogram).T
```
<br>

## Fast Fourier Transform frequency

**FFT ê²°ê³¼ì— í•´ë‹¹í•˜ëŠ” ì£¼íŒŒìˆ˜ ë°°ì—´ ìƒì„± í•¨ìˆ˜** <br>
í•´ìƒë„ë¥¼ ë†’ì´ëŠ” **Ram-Lak Filter**ëŠ” **ì£¼íŒŒìˆ˜ í•„í„°**ì´ê¸° ë•Œë¬¸ì— ì£¼íŒŒìˆ˜ë¡œ ë°”ê¿”ì¤˜ì•¼í•œë‹¤.

```python
# n : ìƒ˜í”Œ ê°œìˆ˜, d : ìƒ˜í”Œ ê°„ê²©
def fftfreq(n, d=1.0):

    # ì£¼íŒŒìˆ˜ ê°„ê²© = 1 / ì „ì²´ êµ¬ê°„ ê¸¸ì´(n * d)
    Hz = 1.0 / (n * d)

    results = np.arange(n)

    # FFT, DFTì˜ ê²°ê³¼ëŠ” ì–‘ìˆ˜ ìŒìˆ˜ê°€ ê³µì¡´í•´ìˆë‹¤
    # ìŒë¶€ë¶€ë¶„ë„ í‘œí˜„í•˜ê¸° ìœ„í•´ ë’¤ìª½ ìŒìˆ˜ë¶€ë¶„ì„ ì–‘ìˆ˜ë¡œ ë°”ê¿”ì¤€ë‹¤
    negative_n = (n + 1) // 2
    results[negative_n:] -= n

    # ì‹¤ì œ ì£¼íŒŒìˆ˜ = ì£¼íŒŒìˆ˜ì¸ë±ìŠ¤ * ë‹¨ì£¼íŒŒìˆ˜
    return results * val
```
<br>

## Ram-Lak Filter

**ì—­ ë¼ëˆ ë³€í™˜ì—ì„œ ì²«ë²ˆì§¸ ê³¼ì •ì¸ í•„í„°ë§ ê³¼ì •ì—ì„œ í•„ìˆ˜ì ì¸ í•¨ìˆ˜ì´ë‹¤**
<br>

**ê³¼ì • ìš”ì•½** <br>

> - ì•ì„œ ë§Œë“  fft_freq()ë¡œ ì£¼íŒŒìˆ˜ ì¶•ì„ ìƒì„±í•œë‹¤
> - ì£¼íŒŒìˆ˜ ì¶•ìœ¼ë¡œ Ram-Lak Filterë¥¼ ìƒì„±í•œë‹¤
> - FFT ê²°ê³¼ ì£¼íŒŒìˆ˜ ì¶•ì„ ê³±í•´ ì£¼íŒŒìˆ˜ í•„í„°ë§ì„ í•œë‹¤
> - ë°°ì—´ì„ ë‹¤ì‹œ ì›ë˜ í¬ê¸°ë¡œ ë§Œë“¤ì–´ ì¤€ í›„ ë¦¬í„´í•œë‹¤
<br>

```python
# í•„í„°ë§ ì‹œí‚¬ sinogramê³¼ ì£¼íŒŒìˆ˜ ë³€í™˜ì— í•„ìš”í•œ FFT, fft_freqë¥¼ ë„£ëŠ”ë‹¤
def Ram_Lak(sinogram, FFT, fft_freq):

    # í•œ ë°©í–¥ì—ì„œì˜ í”½ì…€
    n = sinogram.shape[0]

    # ì£¼íŒŒìˆ˜ ì¶• ìƒì„±
    # í‘¸ë¦¬ì— ë³€í™˜ ê²°ê³¼ì˜ ì¸ë±ìŠ¤ì˜ Hz
    Hz = fft_freq(n)

    # ì£¼íŒŒìˆ˜ì˜ í¬ê¸°ë§Œ í•„ìš”í•˜ê¸° ë•Œë¬¸ì— ì ˆëŒ€ì¹˜ ì”Œìš´ë‹¤
    # ê³ ì—­í†µê³¼ í•„í„° (high-pass filter)
    ramp = np.abs(Hz)

    # í•„í„°ë§ ê²°ê³¼ ë°°ì—´
    filtered = np.zeros_like(sinogram, dtype=np.float64)

    # ê°ë„ë³„ë¡œ ë°˜ë³µ
    for i in range(sinogram.shape[1]):

        # i ë²ˆì§¸ ê°ë„ ì„ ì ë¶„ ê²°ê³¼
        signal = sinogram[:, i]
        signal_len = len(signal)

        # FFTë¥¼ ìœ„í•œ zero-pedding ìˆ˜í–‰
        padded_len = 2 ** int(np.ceil(np.log2(signal_len)))
        signal_padded = np.pad(signal, (0, padded_len - signal_len))

        # FFT ìˆ˜í–‰ (ì£¼íŒŒìˆ˜ ë„ë©”ì¸ìœ¼ë¡œ ë³€í™˜)
        spectrum = FFT(signal_padded)

        # ê²°ê³¼ê°’ì„ ë‹´ì„ í•„í„°ë„ zero-peddingìœ¼ë¡œ ê¸¸ì´ ë§ì¶°ì¤€ë‹¤
        ramp_padded = np.pad(ramp, (0, len(spectrum) - len(ramp)))

        # Ram-lak filterì˜ ëª©ì 
        # ì£¼íŒŒìˆ˜ í•„í„°ë§ì€ ë‹¨ìˆœí•œ ê³±ì…ˆìœ¼ë¡œ ì´ë£¨ì–´ì§„ë‹¤
        # ì‹œê°„ ë„ë©”ì¸ì—ì„œ í•„í„°ë§ì€ ë³µì¡í•˜ì§€ë§Œ ì£¼íŒŒìˆ˜ëŠ” í•„í„°ì™€ ê³±í•˜ê¸°ë§Œ í•˜ë©´ ëœë‹¤
        spectrum_filtered = spectrum * ramp_padded

        # ì—­ í‘¸ë¦¬ì— ë³€í™˜
        inverse_fft = np.conj(FFT(np.conj(spectrum_filtered))) / len(spectrum_filtered)

        # ì‹¤ìˆ˜ ë¶€ë§Œ ì¶”ì¶œ, ì›ë˜ ê¸¸ì´ë¡œ ë˜ëŒë¦°ë‹¤
        filtered[:, i] = np.real(inverse_fft[:signal_len])

    return filtered
```

## Inverse Radon Transform

```python
def inverse_radon(sinogram, theta, FFT, fft_freq, size = None):
    
    h, w = sinogram.shape

    # ì‚¬ì´ì¦ˆë¥¼ ì§€ì •í•˜ì§€ ì•Šì•˜ì„ê²½ìš° sinogramí¬ê¸°ì— ë§ì¶˜ë‹¤
    if size is None:
        size = h

    # sinogramì„ ì£¼íŒŒìˆ˜ ë„ë©”ì¸ í•„í„°ë§ í•œë‹¤
    filtered = Ram_Lak(sinogram, FFT, fft_freq)

    # ì—­ë³€í™˜ ê²°ê³¼ ë°°ì—´ ìƒì„±
    inverse_transform = np.zeros((size, size), dtype = np.float32)

    # ì—­ë³€í™˜ ê²°ê³¼ ë‹´ì„ ì¢Œí‘œ ìƒì„±
    # ì´ë¯¸ì§€ë¥¼ ì¤‘ì‹¬ì— ì˜¤ê²Œí•˜ê¸° ìœ„í•´ ì¢Œí‘œë¥¼ ì¤‘ì‹¬ìœ¼ë¡œ ë§ì¶˜ë‹¤
    mid = size // 2
    x = np.arange(size) - mid
    y = np.arange(size) - mid
    # ì´ë¯¸ì§€ ì¤‘ì‹¬ì— ì˜¤ê²Œí•˜ëŠ” (x, y)ì¢Œí‘œ ìŒ ìƒì„±
    X, Y = np.meshgrid(x, y)

    # ë§ˆì°¬ê°€ì§€ë¡œ ê°ë„ë³„ë¡œ Backprojection ìˆ˜í–‰í•œë‹¤
    for i, angle in enumerate(theta):

        # sinogram í•œì¤„ ì¶”ì¶œí•œë‹¤
        sinogram = filtered[:, i]

        # ì—­ë³€í™˜ ì´ë¯€ë¡œ ê°ë„ëŠ” ë°˜ëŒ€ë¡œ ëŒë¦°ë‹¤
        line = np.tile(sinogram, (size, 1))

        # ë¼ëˆë³€í™˜ê³¼ ë™ì¼í•˜ê²Œ ëˆ„ì ì‹œí‚¨ë‹¤
        rotated = rotate(line, angle = -angle, reshape=False, order=1)
        inverse_transform += rotated

    # ì •ê·œí™”(Nomalization)
    # ê°ë„ë³„ë¡œ ëˆ„ì ëœ ê°’ì´ ì»¤ì§€ê¸° ë•Œë¬¸ì— ë„ˆë¬´ ë°ì•„ì§€ê±°ë‚˜ ì™œê³¡ë  ìˆ˜ ìˆë‹¤
    # ë³´ì • ê³„ìˆ˜ :pi / 2N(ê°ë„ ìˆ˜)
    inverse_transform *= np.pi / (2 * len(theta))

    return inverse_transform
```


### Data Loading

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import rotate
from skimage.transform import radon
```

```python
# dataset íŒŒì¼ í™•ì¸ì„ ìœ„í•´ ì£¼í”¼í„° ë…¸íŠ¸ë¶ì—ì„œ ì‹¤í–‰
import numpy as np

data = np.load('dataset.npz', allow_pickle=True)
image = data['image']

print("type:", type(image))
print("shape:", getattr(image, 'shape', 'No shape'))
print("dtype:", image.dtype if isinstance(image, np.ndarray) else 'Not ndarray')
```
<br>
![image](https://github.com/user-attachments/assets/fda5c554-5700-4d59-8149-22ef5bc5e687)
<br>
**475ê°œì˜ ì´ë¯¸ì§€ë¥¼ ê°–ê³ ìˆë‹¤** 
<br>

```python
data = np.load('dataset.npz', allow_pickle=True)

## ì²«ë²ˆì§¸ ì´ë¯¸ì§€ ì‚¬ìš©
image = data['image'][0]
```
```python
# ì»¬ëŸ¬ë¥¼ í‘ë°±ìœ¼ë¡œ ë³€í™˜
if image.ndim == 3 and image.shape[2] == 3:
    image = np.mean(image, axis=2)

# 0ë„ë¶€í„° 180ë„ê¹Œì§€ ê· ë“±í•˜ê²Œ ê°ë„ ìƒ
theta = np.linspace(0., 180., max(image.shape), endpoint=False)
```

### Use Function

```python
sinogram = radon_transform(image, theta)

reconstructed = inverse_radon(sinogram, theta, FFT, fft_freq)
```

### Visualization

```python
# ë¼ëˆ ì—­ë³€í™˜ ì ìš©
reconstructed = inverse_radon(sinogram, theta, FFT, fft_freq)

plt.figure(figsize=(18, 6))

plt.subplot(1, 3, 1)
plt.title("ì›ë³¸ ì´ë¯¸ì§€")
plt.imshow(image, cmap='gray')
plt.axis('off')

plt.subplot(1, 3, 2)
plt.title("Sinogram")
plt.imshow(sinogram, cmap='gray', aspect='auto')
plt.xlabel("Angle")
plt.ylabel("Detector pixel")

plt.subplot(1, 3, 3)
plt.title("Inverse Radon Transfrom")
plt.imshow(reconstructed, cmap='gray')
plt.axis('off')

plt.tight_layout()
plt.show()
```
<br>

**output**<br>

**dataset 0ë²ˆì§¸ ì´ë¯¸ì§€**<br>

![image](https://github.com/user-attachments/assets/a8110208-6749-43a9-8a6b-bf78468cce54)
<br>

**dataset 1ë²ˆì§¸ ì´ë¯¸ì§€**<br>

![image](https://github.com/user-attachments/assets/ce60ca8a-f9e7-4fce-9776-67512e236583)
























